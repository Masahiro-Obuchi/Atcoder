#include <bits/stdc++.h>
using namespace std;

int main()
{
  int X;
  cin >> X;
  vector<bool> expo(X + 1);

  expo[1] = 1;
  for (int b = 2; b <= X; b++)
  {
    int v = b * b; // 考えているのはべき乗数
    while (v <= X)
    {
      expo[v] = 1; // べき乗数ならばtrue
      v *= b;      // べき数を増やす
    }
  }
  for (int i = X; i >= 1; i--)
  {
    if (expo[i])
    {
      cout << i << endl;
      return 0;
    }
  }
}

// 各1以上X以下の整数に対して，expo = xがべき乗数かという真偽値を考える．これが正しく計算できれば答えは求まる．1以上の整数bと，2以上の整数p全てのペに対してx=b^pを計算し，xが1以上，X以下ならexpoをtrueに書き換えるということをすると定義より正しく求まりますが，当然すべての整数のペアを試すのは不可能．まず，bとして試すべき値は1以上X以下の整数のみでよい．（なぜなら，b>Xなら任意のp>=2に対してb^p > Xだから答えに影響を及ぼさない）同様に，pとして試すべき値は2以上X以下の整数のみで十分である．よって二重ループでb, pの全てのペアを試すことでexpoが正しく求まる．時間計算量はO(X^2)である．しかし，オーバーフローを起こさないためにも以下の方法が良い．各bに対して，p = 2, 3, ...と順番にexpoをtrueに書き換えていく．ここで，もし今調べている値がb^kがXより大きかったら，k以降の値はpとして考える必要がない．したがってそこでpのループを打ち切ってよい．ただしb=1の時にはこの条件での打ち切りは発生しないので注意
